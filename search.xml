<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot国际化</title>
      <link href="/2019/spring-boot-i18n/"/>
      <url>/2019/spring-boot-i18n/</url>
      
        <content type="html"><![CDATA[<p>我们可以利用MessageSource接口中的getMessage方法去访问本地化资源文件</p><p>MessagesSource只是一个接口，真正的实现类是ResourceBundleMessageSource, 它默认会加载classpath路径下messages开头的properties文件。如果要自定义路径，配置spring.messages.basename的值即可。默认格式是messages_国家_地区.properties。我们这里省略了地区。</p><p><img src="ResourceBundleMessageSource.png" alt="ResourceBundleMessageSource"></p><p>LocaleContextHolder类中的getLocale方法可以获取请求中Accept-Language属性的值,如果获取不到语言类型，会去messages.properties文件中去找</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> 国际化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 国际化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2019/singleton-pattern/"/>
      <url>/2019/singleton-pattern/</url>
      
        <content type="html"><![CDATA[<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><h2 id="单例模式的实现方式"><a href="#单例模式的实现方式" class="headerlink" title="单例模式的实现方式"></a>单例模式的实现方式</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p><strong>延迟初始化</strong>：否<br><strong>多线程安全</strong>：是</p><p><strong>优点</strong>：没有加锁，执行效率会提高。<br><strong>缺点</strong>：类加载时就初始化，浪费内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。</p></blockquote><h3 id="双检锁-双重校验锁-DCL"><a href="#双检锁-双重校验锁-DCL" class="headerlink" title="双检锁/双重校验锁 DCL"></a>双检锁/双重校验锁 DCL</h3><p><strong>延迟初始化</strong>：是<br><strong>多线程安全</strong>：是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种方式采用双锁机制，安全且在多线程情况下能保持高性能。这里必须添加<strong>volatile</strong> 关键字，使得该实例对其他线程可见，不然会有小概率导致多线程不安全，具体出现的情况有可能是空指针异常。一个线程已经已经将singleton 的引用指向了一块内存地址，但是对象还为空，但其它线程不可见，判断不为null就直接返回了。</p></blockquote><h3 id="登记式-静态内部类"><a href="#登记式-静态内部类" class="headerlink" title="登记式/静态内部类"></a>登记式/静态内部类</h3><p><strong>延迟初始化</strong>：是<br><strong>多线程安全</strong>：是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 1 种方式不同的是：第 1 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 1 种方式就显得很合理。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP协议</title>
      <link href="/2019/tcp/"/>
      <url>/2019/tcp/</url>
      
        <content type="html"><![CDATA[<p>在介绍TCP协议之前，需要先了解一下<code>4/7层网络模型</code></p><h2 id="4-7层网络模型"><a href="#4-7层网络模型" class="headerlink" title="4/7层网络模型"></a>4/7层网络模型</h2><h2 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h2><ul><li>基于链接(点对点)</li><li>双工通信</li><li>可靠传输</li><li>拥塞控制,在网络状况不佳的时候尽量降低系统由于重传带来的带宽开销</li><li>基于字节流而非报文</li></ul><h2 id="建立链接三次握手"><a href="#建立链接三次握手" class="headerlink" title="建立链接三次握手"></a>建立链接三次握手</h2><p>三次握手，简单来说，就是：</p><ul><li>发送方：我要和你建立链接了哦!</li><li>接收方：你真的要和我建立链接吗?</li><li>发送方：我真的要和你建立链接(成功).</li></ul><blockquote><p><strong>SYN</strong>: (同步序列编号,Synchronize Sequence Numbers)<br><strong>ACK</strong>: (确认编号,Acknowledgement Number)<br><strong>FIN</strong>: (结束标志,FINish)</p></blockquote><p><img src="tcp-3.png" alt="三次握手"></p><ul><li><strong>第一次握手</strong>：Client 将标志位 SYN=1 ，随机产生一个值 seq=J ，并将该数据包发送给 Server 。此时，Client 进入SYN_SENT 状态，等待 Server 确认。</li><li><strong>第二次握手</strong>：Server 收到数据包后由标志位 SYN=1 知道Client请求建立连接，Server 将标志位 SYN 和 ACK 都置为 1 ，ack=J+1，随机产生一个值 seq=K ，并将该数据包发送给 Client 以确认连接请求，Server 进入 SYN_RCVD 状态。此时，Server 进入 SYC_RCVD 状态。</li><li><strong>第三次握手</strong>：Client 收到确认后，检查 ack 是否为 J+1 ，ACK 是否为 1 。<ul><li>如果正确，则将标志位 ACK 置为 1 ，ack=K+1 ，并将该数据包发送给 Server 。此时，Client 进入 ESTABLISHED 状态。</li><li>Server 检查 ack 是否为 K+1 ，ACK 是否为 1 ，如果正确则连接建立成功。此时 Server 进入 ESTABLISHED 状态，完成三次握手，随后 Client 与 Server 之间可以开始传输数据了。</li></ul></li></ul><blockquote><p>仔细看来，Client 会发起两次数据包，分别是 SYNC 和 ACK ；Server 会发起一次数据包，包含 SYNC 和 ACK 。也就是说，三次握手的过程中，Client 和 Server 互相做了一次 SYNC 和 ACK </p></blockquote><blockquote><p>为什么TCP连接需要三次握手，两次不可以么? 这主要是为了防止已失效的连接请求报文突然又传送到了服务端，因而产生错误。防止服务器端一直等待而浪费资源。</p></blockquote><blockquote><p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p></blockquote><h2 id="关闭链接四次挥手"><a href="#关闭链接四次挥手" class="headerlink" title="关闭链接四次挥手"></a>关闭链接四次挥手</h2><p>四次挥手，简单来说，就是：</p><ul><li>发送方：我要和你断开连接！</li><li>接收方：好的，断吧。</li><li>接收方：我也要和你断开连接！</li><li>发送方：好的，断吧。</li></ul><p><img src="tcp-4.png" alt="四次挥手"></p><p><img src="tcp-4-2.png" alt="四次挥手"></p><ul><li><strong>第一次挥手</strong>: Client 发送一个 FIN=M ，用来关闭 Client 到 Server 的数据传送。此时，Client 进入 FIN_WAIT_1 状态。</li><li><strong>第二次挥手</strong>: Server 收到 FIN 后，发送一个 ACK 给 Client ，确认序号为 M+1（与 SYN 相同，一个 FIN 占用一个序号）。此时，Server 进入 CLOSE_WAIT 状态。注意，TCP 链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。</li><li><strong>第三次挥手</strong>: Server 发送一个 FIN=N ，用来关闭 Server 到 Client 的数据传送。此时 Server 进入 LAST_ACK 状态。</li><li><strong>第四次挥手</strong>: Client 收到 FIN 后，此时 Client 进入 TIME_WAIT 状态。接着，Client 发送一个 ACK 给 Server ，确认序号为 N+1 。Server 接收到后，此时 Server 进入 CLOSED 状态，完成四次挥手。</li></ul><h3 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h3><p>那四次分手又是为何呢？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。</p><ul><li><strong>FIN_WAIT_1</strong>: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方）</li><li><strong>FIN_WAIT_2</strong>：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）</li><li><strong>CLOSE_WAIT</strong>：这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。（被动方）</li><li><strong>LAST_ACK</strong>: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）</li><li><strong>TIME_WAIT:</strong> 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）</li><li><strong>CLOSED</strong>: 表示连接中断。</li></ul><h3 id="2MSL-报文最大生存时间"><a href="#2MSL-报文最大生存时间" class="headerlink" title="2MSL - 报文最大生存时间"></a>2MSL - 报文最大生存时间</h3><p>2MSL即两倍的MSL，TCP的TIME_WAIT状态也称为2MSL等待状态，当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次握手完成后发送了第四次握手的ACK包后就进入了TIME_WAIT状态，必须在此状态上停留两倍的MSL时间，等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。</p><h2 id="报文状态标志于连接状态"><a href="#报文状态标志于连接状态" class="headerlink" title="报文状态标志于连接状态"></a>报文状态标志于连接状态</h2><ul><li><strong>CLOSED</strong>: 表示初始状态。</li><li><strong>LISTEN</strong>: 表示服务器端的某个SOCKET处于监听状态，可以接受连接。</li><li><strong>SYN_SENT</strong>:在服务端监听后，客户端SOCKET执行CONNECT连接时，客户端发送SYN报文，此时客户端就进入<br>SYN_SENT状态，等待服务端的确认</li><li><strong>SYN_RCVD</strong>: 表示服务端接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三<br>次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一<br>个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态时，当收到客户端的<br>ACK报文后，它会进入到ESTABLISHED状态。</li><li><strong>ESTABLISHED</strong>: 表示连接已经建立了。</li><li><strong>FIN_WAIT_1</strong>: 这个是已经建立连接之后，其中一方请求终止连接，等待对方的FIN报文。FIN_WAIT_1状态是当<br>SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1<br>状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下<br>，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用<br>netstat看到。</li><li><strong>FIN_WAIT_2</strong>: 实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对<br>方，我暂时还有点数据需要传送给你，稍后再关闭连接。</li><li><strong>TIME_WAIT</strong>: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果<br>FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须<br>经过FIN_WAIT_2状态。</li><li><strong>CLOSING</strong>: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你<br>发送FIN报文后，按理来说是应该先收到(或同时收到)对方的ACK报文，再收到对方的FIN报文。但是CLOSING状<br>态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此<br>种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现<br>了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</li><li><strong>CLOSE_WAIT</strong>: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给<br>自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真<br>正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发<br>送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。</li><li><strong>LAST_ACK</strong>: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。<br>当收到ACK报文后，也即可以进入到CLOSED可用状态了。</li></ul><h2 id="Nagel算法与ACK延迟"><a href="#Nagel算法与ACK延迟" class="headerlink" title="Nagel算法与ACK延迟"></a>Nagel算法与ACK延迟</h2><p><a href="https://www.cnblogs.com/wanpengcoder/p/5366156.html" target="_blank" rel="noopener">TCP之Nagle算法&amp;&amp;延迟ACK</a></p><h2 id="滑动窗口与流量控制"><a href="#滑动窗口与流量控制" class="headerlink" title="滑动窗口与流量控制"></a>滑动窗口与流量控制</h2><p>滑动窗口协议（Sliding Window Protocol），属于TCP协议的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输，提高网络吞吐量。</p><p>TCP采用可变滑动窗口来实现流量控制。TCP连接的两端交互作用，互相提供数据流的相关信息，包括报文段序列号、ACK号和窗口大小（即接收端的可用空间）。发送端根据这些信息动态调节窗口大小来控制发送，以达到流量控制的目的。每个TCP头部的窗口大小字段表明接收端可用缓存空间的大小，以字节为单位。该字段长度为16位，但窗口缩放选项可用大于65535的值。报文段发送方在相反方向上可接受的最大序列号值为TCP头部中ACK号和窗口大小字段之和（单位保持一致）。</p><p><a href="https://blog.csdn.net/qq_37653144/article/details/82765098" target="_blank" rel="noopener">TCP滑动窗口与流量控制</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> 协议 </category>
          
          <category> TCP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2019/linux-common-command/"/>
      <url>/2019/linux-common-command/</url>
      
        <content type="html"><![CDATA[<p>Linux常用命令对服务问题的排查和定位有很大帮助, 这里整理总结一下工作中常用的命令</p><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>下面的例子主要来自于阮一峰的博客。<br>Awk是一种便于使用且表达能力强的程序设计语言，可应用于各种计算和数据处理任务。它依次处理文件的每一行，并读取里面的每一个字段。对于日志、CSV 那样的每行格式相同的文本文件，awk可能是最方便的工具。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><blockquote><p>awk 动作 文件名</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;print $0&#125;'</span> demo.txt</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'this is a test'</span> | awk <span class="string">'&#123;print $0&#125;'</span></span><br></pre></td></tr></table></figure><p><code>this is a test</code></p><p>上面代码中，print $0就是把标准输入this is a test，重新打印了一遍。</p><p>awk会根据空格和制表符，将每一行分成若干字段，依次用$1、$2、$3代表第一个字段、第二个字段、第三个字段等等。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'this is a test'</span> | awk <span class="string">'&#123;print $4&#125;'</span></span><br></pre></td></tr></table></figure><p><code>test</code></p><p>创建一个demo.txt文件,下面是文件内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/usr/bin/zsh</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync</span><br></pre></td></tr></table></figure><p>这个文件的字段分隔符是冒号（:），所以要用-F参数指定分隔符为冒号。然后，才能提取到它的第一个字段。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F <span class="string">':'</span> <span class="string">'&#123; print $1 &#125;'</span> demo.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">daemon</span><br><span class="line">bin</span><br><span class="line">sys</span><br><span class="line">sync</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>除了<code>$ +</code>数字表示某个字段，awk还提供其他一些变量。</p><p>变量<code>NF</code>表示当前行有多少个字段，因此<code>$NF</code>就代表最后一个字段。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'this is a test'</span> | awk <span class="string">'&#123;print $NF&#125;'</span></span><br></pre></td></tr></table></figure><p><code>test</code></p><p><code>$(NF-1)</code>代表倒数第二个字段。print命令里面的逗号，表示输出的时候，两个部分之间使用空格分隔。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F <span class="string">':'</span> <span class="string">'&#123;print $1, $(NF-1)&#125;'</span> demo.txt</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root /root</span><br><span class="line">daemon /usr/sbin</span><br><span class="line">bin /bin</span><br><span class="line">sys /dev</span><br><span class="line">sync /bin</span><br></pre></td></tr></table></figure><p>变量<code>NR</code>表示当前处理的是第几行, <code>print</code>命令里面，如果原样输出字符，要放在双引号里面。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F <span class="string">':'</span> <span class="string">'&#123;print NR ") " $1&#125;'</span> demo.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1) root</span><br><span class="line">2) daemon</span><br><span class="line">3) bin</span><br><span class="line">4) sys</span><br><span class="line">5) sync</span><br></pre></td></tr></table></figure><p>awk常用内置变量如下:</p><ul><li>NF: 当前行有多少个字段</li><li>NR: 当前处理的是第几行</li><li>FILENAME: 当前文件名</li><li>FS: 字段分隔符，默认是空格和制表符。</li><li>RS: 行分隔符，用于分割每一行，默认是换行符。</li><li>OFS: 输出字段的分隔符，用于打印时分隔字段，默认为空格。</li><li>ORS: 输出记录的分隔符，用于打印时分隔记录，默认为换行符。</li><li>OFMT: 数字输出的格式，默认为％.6g</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>awk还提供了一些内置函数，方便对原始数据的处理。</p><p>函数<code>toupper()</code>用于将字符转为大写。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F <span class="string">':'</span> <span class="string">'&#123; print toupper($1) &#125;'</span> demo.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ROOT</span><br><span class="line">DAEMON</span><br><span class="line">BIN</span><br><span class="line">SYS</span><br><span class="line">SYNC</span><br></pre></td></tr></table></figure><p>其他常用函数如下:</p><ul><li>toupper(): 字符转为大写。</li><li>tolower(): 字符转为小写。</li><li>length(): 返回字符串长度。</li><li>substr(): 返回子字符串。</li><li>sin(): 正弦。</li><li>cos(): 余弦。</li><li>sqrt(): 平方根。</li><li>rand(): 随机数。</li></ul><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>awk允许指定输出条件，只输出符合条件的行。</p><blockquote><p>awk ‘条件 动作’ 文件名</p></blockquote><p>下面的代码print命令前面是一个正则表达式，只输出包含usr的行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F <span class="string">':'</span> <span class="string">'/usr/ &#123;print $1&#125;'</span> demo.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">daemon</span><br><span class="line">bin</span><br><span class="line">sys</span><br></pre></td></tr></table></figure><p>下面的例子只输出奇数行，</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F <span class="string">':'</span> <span class="string">'NR % 2 == 1 &#123;print $1&#125;'</span> demo.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">bin</span><br><span class="line">sync</span><br></pre></td></tr></table></figure><p>下面的例子只输出第三行以后的行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F <span class="string">':'</span> <span class="string">'NR &gt;3 &#123;print $1&#125;'</span> demo.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sys</span><br><span class="line">sync</span><br></pre></td></tr></table></figure><p>下面的例子输出第一个字段等于指定值的行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F <span class="string">':'</span> <span class="string">'$1 == "root" || $1 == "bin" &#123;print $1&#125;'</span> demo.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">bin</span><br></pre></td></tr></table></figure><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><p>awk提供了if结构，用于编写复杂的条件。</p><p>下面的代码输出第一个字段的第一个字符大于m的行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F <span class="string">':'</span> <span class="string">'&#123;if ($1 &gt; "m") print $1&#125;'</span> demo.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">sys</span><br><span class="line">sync</span><br></pre></td></tr></table></figure><p>if结构还可以指定else部分。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F <span class="string">':'</span> <span class="string">'&#123;if ($1 &gt; "m") print $1; else print "---"&#125;'</span> demo.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root</span><br><span class="line">---</span><br><span class="line">---</span><br><span class="line">sys</span><br><span class="line">sync</span><br></pre></td></tr></table></figure><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>top命令经常用来监控Linux的系统状况，比如cpu、内存的使用，程序员基本都知道这个命令，但比较奇怪的是能用好它的人却很少，例如top监控视图中内存数值的含义就有不少的曲解。</p><p>本文通过一个运行中的WEB服务器的top监控截图，讲述top视图中的各种数据的含义，还包括视图中各进程（任务）的字段的排序。</p><p><img src="top-pic1.png" alt="TOP"></p><h3 id="TOP基本视图数据含义"><a href="#TOP基本视图数据含义" class="headerlink" title="TOP基本视图数据含义"></a>TOP基本视图数据含义</h3><ul><li><p>第一行：</p><ul><li><strong>19:05:32</strong> : 当前系统时间</li><li><strong>42 days, 19:05:</strong> : 系统已经运行了42天19小时05分钟（在这期间没  重启过）</li><li><strong>2 users</strong> : 当前有2个用户登录系统</li><li><strong>load average: 0.23, 0.26. 0.27</strong> : load average后面的三个数  别是1分钟、5分钟、15分钟的负载情况</li></ul><blockquote><p>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</p></blockquote></li><li><p>第二行：进程</p><ul><li><strong>168 total</strong> : 系统现在共有168个进程</li><li><strong>2 running</strong> : 其中处于运行中的有2个</li><li><strong>166 sleeping</strong> : 166个在休眠</li><li><strong>0 stopped</strong> : stoped状态的有0个</li><li><strong>0 zombie</strong> : 僵尸状态的有0个</li></ul></li><li><p>第三行：cpu状态</p><ul><li><strong>12.5% us</strong> : 用户空间占用CPU的百分比。</li><li><strong>4.2% sy</strong> : 内核空间占用CPU的百分比。</li><li><strong>0.5% ni</strong> : 改变过优先级的进程占用CPU的百分比</li><li><strong>82.8% id</strong> : 空闲CPU百分比</li><li><strong>0.0% wa</strong> : IO等待占用CPU的百分比</li><li><strong>0.0% hi</strong> : 硬中断（Hardware IRQ）占用CPU的百分比</li><li><strong>0.0% si</strong> : 软中断（Software Interrupts）占用CPU的百分比</li></ul><blockquote><p>在这里CPU的使用比率和windows概念不同，如果你不理解用户空间和内核空间，需要了解一下。</p></blockquote></li></ul><ul><li><p>第四行：内存状态</p><ul><li><strong>5994240k total</strong> : 物理内存总量</li><li><strong>5751368k used</strong> : 使用中的内存总量</li><li><strong>242872k free</strong> : 空闲内存总量</li><li><strong>10476k buffers</strong> : 缓存的内存量</li></ul><blockquote><p>这里要说明的是不能用windows的内存概念理解这些数据，如果按windows的方式此台服务器“危矣”：8G的内存总量只剩下530M的可用内存。Linux的内存管理有其特殊性，复杂点需要一本书来说明，这里只是简单说点和我们传统概念（windows）的不同。</p></blockquote><blockquote><p>第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。</p></blockquote></li><li><p>第五行：swap交换分区</p><ul><li><strong>15999996k total</strong> : 交换区总量</li><li><strong>1520700k used</strong>: 使用的交换区总量</li><li><strong>14479296k free</strong>: 空闲交换区总量</li><li><strong>554840k cached</strong>: 缓冲的交换区总量</li></ul><blockquote><p>如果出于习惯去计算可用内存数，这里有个近似的计算公式：第四行的free + 第四行的buffers + 第五行的cached，按这个公式此台服务器的可用内存： 242872+10476+554840 = 808,188kb = 789MB。</p></blockquote><blockquote><p>对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。</p></blockquote></li><li><p>第六行:空行</p></li></ul><ul><li>第七行以下：各进程（任务）的状态监控<ul><li><strong>PID</strong> : 进程id</li><li><strong>USER</strong> : 进程所有者</li><li><strong>PR</strong> : 进程优先级</li><li><strong>NI</strong> : nice值。负值表示高优先级，正值表示低优先级</li><li><strong>VIRT</strong> : 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</li><li><strong>RES</strong> : 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</li><li><strong>SHR</strong> : 共享内存大小，单位kb</li><li><strong>S</strong> : 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</li><li><strong>%CPU</strong> : 上次更新到现在的CPU时间占用百分比</li><li><strong>%MEM</strong> : 进程使用的物理内存百分比</li><li><strong>TIME+</strong> : 进程使用的CPU时间总计，单位1/100秒</li><li><strong>COMMAND</strong> : 进程名称（命令名/命令行）</li></ul></li></ul><h3 id="多核CPU监控"><a href="#多核CPU监控" class="headerlink" title="多核CPU监控"></a>多核CPU监控</h3><p>在top基本视图中，按键盘数字<code>1</code>，可监控每个逻辑CPU的状况</p><h3 id="top列排序"><a href="#top列排序" class="headerlink" title="top列排序"></a>top列排序</h3><p>top默认的排序列是 <strong>%CPU</strong>, 通过<code>shift + &gt;</code>或<code>shift + &lt;</code>可以向右或左改变排序列</p><h3 id="设置信息更新时间"><a href="#设置信息更新时间" class="headerlink" title="设置信息更新时间"></a>设置信息更新时间</h3><p><code>top -d 3</code><br>表示更新周期为3秒</p><h3 id="显示指定的进程信息"><a href="#显示指定的进程信息" class="headerlink" title="显示指定的进程信息"></a>显示指定的进程信息</h3><p><code>top -p 139</code><br>显示进程号为139的进程信息，CPU、内存占用率等</p><h3 id="显示更新指定次后退出"><a href="#显示更新指定次后退出" class="headerlink" title="显示更新指定次后退出"></a>显示更新指定次后退出</h3><p><code>top -n 10</code><br>更新十次后退出</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep 命令用于查找文件里符合条件的字符串。工作中我常用来过滤日志中的一些关键信息.</p><p>过滤出所有日志中的异常信息行, 取结果前20条开看看, <code>-B1</code>指取匹配到的前一行, <code>-i</code>忽略大小写</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i <span class="string">"Exception"</span> mcserver.log.* -B1 | head -n 20</span><br></pre></td></tr></table></figure><p>下面这个<code>-c</code>可以统计每个文件里面匹配到的个数, 列出所有文件, 可以用来缩小文件范围</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i <span class="string">"Exception"</span> mcserver.log.* -c</span><br></pre></td></tr></table></figure><p><code>-v</code>表示显示不包含匹配文本的所有行, <code>{1..3}</code>表示取1到3</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v <span class="string">"Exception"</span> mcserver.log.&#123;1..3&#125; -c</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mcserver.log.1:102398</span><br><span class="line">mcserver.log.2:105916</span><br><span class="line">mcserver.log.3:101884</span><br></pre></td></tr></table></figure><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p>sed 命令是利用脚本来处理文本文件。sed 可依照脚本的指令来处理、编辑文本文件。主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p><p>下面是test.txt的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/bin/sh</span><br><span class="line">bin:x:2:2:bin:/bin:/bin/sh</span><br><span class="line">sys:x:3:3:sys:/dev:/bin/sh</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync</span><br></pre></td></tr></table></figure><p>以行为单位的新增/删除，将文件的2-3行删除</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'2,3d'</span> test.txt</span><br></pre></td></tr></table></figure><p>数据的搜寻并替换，将root替换为admin</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'s/root/admin/g'</span> test.txt</span><br></pre></td></tr></table></figure><p>在第二行添加<code>&quot;ignore_vc_cert&quot;=false</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'2a "ignore_vc_cert"=false'</span> test.txt</span><br></pre></td></tr></table></figure><p>匹配到包含<code>&quot;ignore_vc_cert&quot;</code>的那一行，然后将false替换为true</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'/"ignore_vc_cert"/ s/false/true/'</span> test.txt</span><br></pre></td></tr></table></figure><hr><p>以后再更新，目前工作中常用的就这些</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux常用命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/2019/markdown-basic-syntax/"/>
      <url>/2019/markdown-basic-syntax/</url>
      
        <content type="html"><![CDATA[<p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。<br>Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 这是一级标题</span></span><br><span class="line"><span class="section">## 这是二级标题</span></span><br><span class="line"><span class="section">### 这是三级标题</span></span><br><span class="line"><span class="section">#### 这是四级标题</span></span><br><span class="line"><span class="section">##### 这是五级标题</span></span><br><span class="line"><span class="section">###### 这是六级标题</span></span><br></pre></td></tr></table></figure><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul><li><p><strong>加粗:要加粗的文字左右分别用两个*号包起来</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**加粗**</span></span><br></pre></td></tr></table></figure></li><li><p><em>斜体:要倾斜的文字左右分别用一个*号包起来</em></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span></span><br></pre></td></tr></table></figure></li><li><p><strong><em>斜体加粗:要倾斜和加粗的文字左右分别用三个*号包起来</em></strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">***斜体加粗**</span>*</span><br></pre></td></tr></table></figure></li><li><p><del>删除线:要加删除线的文字左右分别用两个\</del>~号包起来~~</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>引用的内容</p><blockquote><p>引用的内容</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;引用的内容</span><br><span class="line">&gt;&gt;引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;引用的内容</span><br></pre></td></tr></table></figure><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><blockquote><p>三个或者三个以上的 - 或者 * 都可以</p></blockquote><hr><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure><hr><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">***</span></span><br></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">图片名称</span>](<span class="link">pic.jpg (图片title</span>))</span><br></pre></td></tr></table></figure><p>图片title(图片title)可以省略</p><p><img src="pic.jpg" alt="图片名称" title="图片title"></p><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">哔哩哔哩</span>](<span class="link">https://www.bilibili.com/ (我是B站忠实用户</span>))</span><br></pre></td></tr></table></figure><blockquote><p>链接title(链接title)可以省略</p></blockquote><p><a href="https://www.bilibili.com/" title="我是B站忠实用户" target="_blank" rel="noopener">哔哩哔哩</a></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>- 列表内容<br>+ 列表内容<br>* 列表内容</p><blockquote><p>注意：- + * 跟内容之间都要有一个空格</p></blockquote><ul><li>列表内容</li><li>列表内容</li><li>列表内容</li></ul><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>列表内容</span><br><span class="line"><span class="bullet">- </span>列表内容</span><br><span class="line"><span class="bullet">- </span>列表内容</span><br></pre></td></tr></table></figure><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>列表内容</span><br><span class="line"><span class="bullet">2. </span>列表内容</span><br><span class="line"><span class="bullet">3. </span>列表内容</span><br></pre></td></tr></table></figure><blockquote><p>注意：数字后面有个.和空格</p></blockquote><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>上一级和下一级之间敲三个空格即可</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th>表头</th><th align="center">表头</th><th align="right">表头</th></tr></thead><tbody><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr></tbody></table><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">表头|表头|表头</span><br><span class="line">---|:--:|---:</span><br><span class="line">内容|内容|内容</span><br><span class="line">内容|内容|内容</span><br></pre></td></tr></table></figure><blockquote><p>第二行分割表头和内容。<br>有一个就行，为了对齐，多加了几个<br>文字默认居左<br>两边加<code>:</code>表示文字居中<br>右边加<code>:</code>表示文字居右<br>注：原生的语法两边都要用 | 包起来。此处省略</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>语法：<br>单行代码：代码之间分别用一个反引号包起来</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`单行代码`</span></span><br></pre></td></tr></table></figure><p>多行用三个```</p><p>😄</p>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2019/java-basic/"/>
      <url>/2019/java-basic/</url>
      
        <content type="html"><![CDATA[<p>这个算是我的第一篇博客吧，我先从Java开始</p><h2 id="接口与抽象类的区别？"><a href="#接口与抽象类的区别？" class="headerlink" title="接口与抽象类的区别？"></a>接口与抽象类的区别？</h2><p>首先要搞懂什么是抽象类，什么是接口</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li>接口不能被实例化</li><li>接口只能包含方法声明</li><li>接口的成员包括方法、属性、索引器、事件</li><li>接口中不能包含常量、字段(域)、构造函数、析构函数、静态成员</li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类不能创建实例，它只能作为父类被继承。抽象类是从多个具体类中抽象出来的父类，它具有更高层次的抽象。从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为其子类的模板，从而避免了子类的随意性。</p><ul><li>抽象方法只作声明，而不包含实现，可以看成是没有实现体的虚方法</li><li>抽象类不能被实例化</li><li>抽象类可以但不是必须有抽象属性和抽象方法，但是一旦有了抽象方法，就一定要把这个类声明为抽象类</li><li>具体派生类必须覆盖基类的抽象方法</li><li>抽象派生类可以覆盖基类的抽象方法，也可以不覆盖。如果不覆盖，则其具体派生类必须覆盖它们</li></ul><h3 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h3><ul><li>抽象类可以有构造方法，接口中不能有构造方法。</li><li>抽象类中可以有普通成员变量，接口中没有普通成员变量</li><li>抽象类中可以包含静态方法，接口中不能包含静态方法</li><li>一个类可以实现多个接口，但只能继承一个抽象类。</li><li>接口可以被多重实现，抽象类只能被单一继承</li><li>如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法</li></ul><h3 id="接口和抽象类的相同点"><a href="#接口和抽象类的相同点" class="headerlink" title="接口和抽象类的相同点"></a>接口和抽象类的相同点</h3><ul><li>都可以被继承</li><li>都不能被实例化</li><li>都可以包含方法声明</li><li>派生类必须实现未实现的方法</li></ul><h2 id="Java中的异常类有哪几类-分别怎么使用"><a href="#Java中的异常类有哪几类-分别怎么使用" class="headerlink" title="Java中的异常类有哪几类?分别怎么使用?"></a>Java中的异常类有哪几类?分别怎么使用?</h2><p>说到异常的分类先从Throwable类说起，Throwable类是Java异常类型的顶层父类，一个对象只有是 Throwable 类的（直接或者间接）实例，他才是一个异常对象，才能被异常处理机制识别。JDK中内建了一些常用的异常类，我们也可以自定义异常。</p><p>Exception分为CheckedException和RuntimeException，所有RuntimeException类及其子类的实例被称为Runtime异常，不属于该范畴的异常则被称为CheckedException。</p><p>Error是程序无法处理的, 如果OutOfMemoryError、OutOfMemoryError等等, 这些异常发生时, java虚拟机一般会终止线程。<br>运行时异常都是RuntimeException类及其子类,如 NullPointerException、IndexOutOfBoundsException等, 这些异常是不检查的异常, 是在程序运行的时候可能会发生的, 所以程序可以捕捉, 也可以不捕捉。这些错误一般是由程序的逻辑错误引起的, 程序应该从逻辑角度去尽量避免。<br>检查异常是运行时异常以外的异常, 也是Exception及其子类, 这些异常从程序的角度来说是必须经过捕捉检查处理的, 否则不能通过编译. 如IOException、SQLException等。</p><p><img src="exception.png" alt="Java异常的分类和类结构图"></p><h3 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h3><p>常见的编译时异常有:</p><ul><li>IOException</li><li>SQLException</li><li>CloneNotSupportedException</li><li>ParseException</li><li>ClassNotFoundException</li><li>NoSuchMetodException</li></ul><h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>常见的运行时异常有:</p><ul><li>NullPointerException: 空指针异常,一般出现于数组,空对-象的变量和方法</li><li>ArrayIndexOutOfBoundsException: 数组越界异常</li><li>ArrayStoreException: 数据存储异常</li><li>NoClassDefFoundException: java运行时系统找不到所引用的类</li><li>ArithmeticException: 算数异常,一般在被除数是0中</li><li>ClassCastException: 类型转换异常</li><li>IllegalArgumentException: 非法参数异常</li><li>IllegalThreadStateException: 非法线程状态异常</li><li>NumberFormatException: 数据格式异常</li><li>OutOfMemoryException: 内存溢出异常</li><li>PatternSyntaxException: 正则异常</li><li>ConcurrentModificationException: 并发修改异常</li></ul><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>创建一个类继承RuntimeException,这样就能创建一个运行时异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TooMuchMoneyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String errorMsg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TooMuchMoneyException</span> <span class="params">(String errorMsg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorMsg);</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要创建一个检查性异常,就继承Exception</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotSuchMoneyFoundException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String errorMsg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NotSuchMoneyFoundException</span><span class="params">(String errorMsg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorMsg);</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 面试题</title>
      <link href="/2019/spring-interview/"/>
      <url>/2019/spring-interview/</url>
      
        <content type="html"><![CDATA[<h2 id="123"><a href="#123" class="headerlink" title="123"></a>123</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="pic.jpg" alt="测试图片"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
