<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java基础"><meta name="keywords" content="Java"><meta name="author" content="Fulin Zhang"><meta name="copyright" content="Fulin Zhang"><title>Java基础 | 个人博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象概念"><span class="toc-number">1.</span> <span class="toc-text">面向对象概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象的特征"><span class="toc-number">2.</span> <span class="toc-text">面向对象的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口与抽象类的区别？"><span class="toc-number">3.</span> <span class="toc-text">接口与抽象类的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#接口"><span class="toc-number">3.1.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类"><span class="toc-number">3.2.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口与抽象类的区别"><span class="toc-number">3.3.</span> <span class="toc-text">接口与抽象类的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口和抽象类的相同点"><span class="toc-number">3.4.</span> <span class="toc-text">接口和抽象类的相同点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-IO"><span class="toc-number">4.</span> <span class="toc-text">Java IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-序列化"><span class="toc-number">5.</span> <span class="toc-text">Java 序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象克隆"><span class="toc-number">6.</span> <span class="toc-text">对象克隆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java中的异常类有哪几类-分别怎么使用"><span class="toc-number">7.</span> <span class="toc-text">Java中的异常类有哪几类?分别怎么使用?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编译时异常"><span class="toc-number">7.1.</span> <span class="toc-text">编译时异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行时异常"><span class="toc-number">7.2.</span> <span class="toc-text">运行时异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义异常"><span class="toc-number">7.3.</span> <span class="toc-text">自定义异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常的使用的注意地方"><span class="toc-number">7.4.</span> <span class="toc-text">异常的使用的注意地方</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射的用途及实现"><span class="toc-number">8.</span> <span class="toc-text">反射的用途及实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class-forName-和-ClassLoader-的区别"><span class="toc-number">9.</span> <span class="toc-text">Class.forName 和 ClassLoader 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-对象创建的方式"><span class="toc-number">10.</span> <span class="toc-text">Java 对象创建的方式</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://iuin.github.io/2019/markdown-basic-syntax/pic.jpg"></div><div class="author-info__name text-center">Fulin Zhang</div><div class="author-info__description text-center">你都还没有成功，有什么理由停下脚步</div><div class="follow-button"><a href="https://github.com/iuin">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">26</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">24</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">31</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="http://www.iocoder.cn/">芋道源码</a><a class="author-info-links__name text-center" href="http://www.importnew.com/">ImportNew</a><a class="author-info-links__name text-center" href="https://www.cnblogs.com/ityouknow">纯洁的微笑</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">个人博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/gallery">相册</a><a class="site-page" href="/slides">幻灯片</a></span></div><div id="post-info"><div id="post-title">Java基础</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-11</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/基础/">基础</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>这个算是我的第一篇博客吧，我先从Java开始</p>
<h2 id="面向对象概念"><a href="#面向对象概念" class="headerlink" title="面向对象概念"></a>面向对象概念</h2><p>面向对象是一种思想，世间万物都可以看做一个对象，这里只讨论面向对象编程（OOP），Java 是一个支持并发、基于类和面向对象的计算机编程语言。面向对象软件开发具有以下优点：</p>
<ul>
<li>代码开发模块化，更易维护和修改。</li>
<li>代码复用性强。</li>
<li>增强代码的可靠性和灵活性。</li>
<li>增加代码的可读性。</li>
</ul>
<h2 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h2><p><strong>封装、继承、多态、抽象</strong></p>
<ol>
<li><p>封装，给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在 Java 当中，有 4 种修饰符： default、public、private 和 protected 。每一种修饰符给其他的位于同一个包或者不同包下面对象赋予了不同的访问权限。<br>下面列出了使用封装的一些好处：</p>
<ul>
<li>通过隐藏对象的属性来保护对象内部的状态。</li>
<li>提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。</li>
<li>禁止对象之间的不良交互提高模块化。</li>
</ul>
</li>
<li><p>继承，给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。</p>
</li>
<li><p>多态，是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作，可以应用到其他类型的值上面。</p>
</li>
<li><p>抽象，是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。<br>Java 支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。</p>
</li>
</ol>
<h2 id="接口与抽象类的区别？"><a href="#接口与抽象类的区别？" class="headerlink" title="接口与抽象类的区别？"></a>接口与抽象类的区别？</h2><p>首先要搞懂什么是抽象类，什么是接口</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>接口不能被实例化</li>
<li>接口只能包含方法声明</li>
<li>接口的成员包括方法、属性、索引器、事件</li>
<li>接口中不能包含常量、字段(域)、构造函数、析构函数、静态成员</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类不能创建实例，它只能作为父类被继承。抽象类是从多个具体类中抽象出来的父类，它具有更高层次的抽象。从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为其子类的模板，从而避免了子类的随意性。</p>
<ul>
<li>抽象方法只作声明，而不包含实现，可以看成是没有实现体的虚方法</li>
<li>抽象类不能被实例化</li>
<li>抽象类可以但不是必须有抽象属性和抽象方法，但是一旦有了抽象方法，就一定要把这个类声明为抽象类</li>
<li>具体派生类必须覆盖基类的抽象方法</li>
<li>抽象派生类可以覆盖基类的抽象方法，也可以不覆盖。如果不覆盖，则其具体派生类必须覆盖它们</li>
</ul>
<h3 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h3><ul>
<li>抽象类可以有构造方法，接口中不能有构造方法。</li>
<li>抽象类中可以有普通成员变量，接口中没有普通成员变量</li>
<li>抽象类中可以包含静态方法，接口中不能包含静态方法</li>
<li>一个类可以实现多个接口，但只能继承一个抽象类。</li>
<li>接口可以被多重实现，抽象类只能被单一继承</li>
<li>如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法</li>
</ul>
<h3 id="接口和抽象类的相同点"><a href="#接口和抽象类的相同点" class="headerlink" title="接口和抽象类的相同点"></a>接口和抽象类的相同点</h3><ul>
<li>都可以被继承</li>
<li>都不能被实例化</li>
<li>都可以包含方法声明</li>
<li>派生类必须实现未实现的方法</li>
</ul>
<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><p><img src="javaIO.jpg" alt="java IO"></p>
<h2 id="Java-序列化"><a href="#Java-序列化" class="headerlink" title="Java 序列化"></a>Java 序列化</h2><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。</p>
<ul>
<li>可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。</li>
<li>序列化是为了解决在对对象流进行读写操作时所引发的问题。<br>反序列化的过程，则是和序列化相反的过程。</li>
</ul>
<blockquote>
<p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p>
<ul>
<li>当对象被序列化时，阻止实例中那些用此关键字修饰的的变量序列化。</li>
<li>当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。</li>
<li>transient 只能修饰变量，不能修饰类和方法。</li>
</ul>
</blockquote>
<h2 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h2><p>一般来说，有两种方式：</p>
<ol>
<li>实现 Cloneable 接口，并重写 Object 类中的 #clone() 方法。可以实现浅克隆，也可以实现深克隆。</li>
<li>实现 Serializable 接口，通过对象的序列化和反序列化实现克隆。可以实现真正的深克隆。</li>
</ol>
<h2 id="Java中的异常类有哪几类-分别怎么使用"><a href="#Java中的异常类有哪几类-分别怎么使用" class="headerlink" title="Java中的异常类有哪几类?分别怎么使用?"></a>Java中的异常类有哪几类?分别怎么使用?</h2><p>说到异常的分类先从Throwable类说起，Throwable类是Java异常类型的顶层父类，一个对象只有是 Throwable 类的（直接或者间接）实例，他才是一个异常对象，才能被异常处理机制识别。JDK中内建了一些常用的异常类，我们也可以自定义异常。</p>
<p>Exception分为CheckedException和RuntimeException，所有RuntimeException类及其子类的实例被称为Runtime异常，不属于该范畴的异常则被称为CheckedException。</p>
<p>Error是程序无法处理的, 如果OutOfMemoryError、OutOfMemoryError等等, 这些异常发生时, java虚拟机一般会终止线程。<br>运行时异常都是RuntimeException类及其子类,如 NullPointerException、IndexOutOfBoundsException等, 这些异常是不检查的异常, 是在程序运行的时候可能会发生的, 所以程序可以捕捉, 也可以不捕捉。这些错误一般是由程序的逻辑错误引起的, 程序应该从逻辑角度去尽量避免。<br>检查异常是运行时异常以外的异常, 也是Exception及其子类, 这些异常从程序的角度来说是必须经过捕捉检查处理的, 否则不能通过编译. 如IOException、SQLException等。</p>
<p><img src="exception.png" alt="Java异常的分类和类结构图"></p>
<h3 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h3><p>常见的编译时异常有:</p>
<ul>
<li>IOException</li>
<li>SQLException</li>
<li>CloneNotSupportedException</li>
<li>ParseException</li>
<li>ClassNotFoundException</li>
<li>NoSuchMetodException</li>
</ul>
<h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>常见的运行时异常有:</p>
<ul>
<li>NullPointerException: 空指针异常,一般出现于数组,空对-象的变量和方法</li>
<li>ArrayIndexOutOfBoundsException: 数组越界异常</li>
<li>ArrayStoreException: 数据存储异常</li>
<li>NoClassDefFoundException: java运行时系统找不到所引用的类</li>
<li>ArithmeticException: 算数异常,一般在被除数是0中</li>
<li>ClassCastException: 类型转换异常</li>
<li>IllegalArgumentException: 非法参数异常</li>
<li>IllegalThreadStateException: 非法线程状态异常</li>
<li>NumberFormatException: 数据格式异常</li>
<li>OutOfMemoryException: 内存溢出异常</li>
<li>PatternSyntaxException: 正则异常</li>
<li>ConcurrentModificationException: 并发修改异常</li>
</ul>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>创建一个类继承RuntimeException,这样就能创建一个运行时异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TooMuchMoneyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String errorMsg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TooMuchMoneyException</span> <span class="params">(String errorMsg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorMsg);</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常的使用的注意地方"><a href="#异常的使用的注意地方" class="headerlink" title="异常的使用的注意地方"></a>异常的使用的注意地方</h3><ul>
<li>不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调用者为了正常的控制流而使用异常）。</li>
<li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常。</li>
<li>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）。</li>
<li>优先使用标准的异常。</li>
<li>每个方法抛出的异常都要有文档。</li>
<li>保持异常的原子性</li>
<li>不要在 catch 中忽略掉捕获到的异常。</li>
</ul>
<p>如果要创建一个检查性异常,就继承Exception</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotSuchMoneyFoundException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String errorMsg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NotSuchMoneyFoundException</span><span class="params">(String errorMsg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorMsg);</span><br><span class="line">        <span class="keyword">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射的用途及实现"><a href="#反射的用途及实现" class="headerlink" title="反射的用途及实现"></a>反射的用途及实现</h2><p>Java 反射机制主要提供了以下功能：</p>
<ul>
<li>在运行时构造一个类的对象。</li>
<li>判断一个类所具有的成员变量和方法。</li>
<li>调用一个对象的方法。</li>
<li>生成动态代理。</li>
</ul>
<p>反射的应用很多，很多框架都有用到：</p>
<ul>
<li>Spring 框架的 IoC 基于反射创建对象和设置依赖属性。</li>
<li>Spring MVC 的请求调用对应方法，也是通过反射。</li>
<li>JDBC 的 Class#forName(String className) 方法，也是使用反射。</li>
</ul>
<h2 id="Class-forName-和-ClassLoader-的区别"><a href="#Class-forName-和-ClassLoader-的区别" class="headerlink" title="Class.forName 和 ClassLoader 的区别"></a>Class.forName 和 ClassLoader 的区别</h2><p>这两者，都可用来对类进行加载。差别在于：</p>
<ul>
<li>Class.forName(…) 方法，除了将类的 .class 文件加载到JVM 中之外，还会对类进行解释，执行类中的 static 块。</li>
<li>ClassLoader 只干一件事情，就是将 .class 文件加载到 JVM 中，不会执行 static 中的内容，只有在 newInstance 才会去执行 static 块。</li>
</ul>
<blockquote>
<p>Class#forName(name, initialize, loader) 方法，带参函数也可控制是否加载 static 块，并且只有调用了newInstance 方法采用调用构造函数，创建类的对象。</p>
</blockquote>
<h2 id="Java-对象创建的方式"><a href="#Java-对象创建的方式" class="headerlink" title="Java 对象创建的方式"></a>Java 对象创建的方式</h2><ol>
<li>使用 new 关键字创建对象。</li>
<li>使用 Class 类的 newInstance 方法(反射机制)。</li>
<li>使用 Constructor 类的 newInstance 方法(反射机制)。</li>
<li>使用 clone 方法创建对象。</li>
<li>使用(反)序列化机制创建对象。</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Fulin Zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://iuin.github.io/2019/java-basic/">https://iuin.github.io/2019/java-basic/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://iuin.github.io">个人博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/markdown-basic-syntax/"><i class="fa fa-chevron-left">  </i><span>Markdown基本语法</span></a></div><div class="next-post pull-right"><a href="/2019/JAVA-interview/"><span>Java 面试题</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By Fulin Zhang</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>